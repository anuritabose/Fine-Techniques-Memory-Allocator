ALLOCATION POLICY USED: Next Fit

BASIC LOGIC USED FOR IMPLEMENTATION: I am using a circular linked list for the book-keeping structure. First, the linked list structure is initialised and when the global character array is allocated, the first node of book-keeping is also created. This linked list keeps a record of which blocks of memory in the character array is free for allocation and which is allocated. mymalloc() is used for allocating a block of memory of requested size based on next fit scheme. When end of memory is reached I start searching the memory from the beginning again for free space in accordance to next fit scheme (reason why I chose circular linked list). myfree() is used for freeing the block of memory. It keeps check of whether neighbouring blocks are also free in order to merge into a single free block. Also, if a newly allocated block is freed and needs merging, the nextfit pointer (explained in next section) takes care of that. print_book() prints the size of the book-keeping node. display_mem_map() displays the details of the character array, printing the start index, block size and encoding of the memory block (in accordance to instructions given to us). 

EXPLANATION OF THE BOOK-KEEPING STRUCTURE: I have used circular linked list for implementation of the book-keeping structure, as I felt this would be most appropriate for the next fit scheme. The structure (BLIST) contains head pointer, tail pointer, nextfit pointer (to point to next free memory block after the most recently allocated memory block), and count (keeps a count of the number of nodes in the linked list). The node structure of the linked list (BNODE) contains a void pointer (pointing to the memory block that the pointer returned by mymalloc is pointing to), blocksize (holds size of the allocated memory block), start index (index position in global character array where the memory block begins), end index (index position in global character array where the memory block ends), next pointer, encoding (holds value 2 for free memory block and 1 for allocated memory block). I use this BNODE to keep track of the free and allocated memory blocks of the global character array. 

ADDITIONAL NOTES: I wanted to state that my book-keeping structure was 24 bytes in size when I used Mingw compiler on my Windows machine. However, it showed 40 bytes using gcc compiler on my Linux machine. Due to this, if this program is being run on Ubuntu, the allocate(200) in the sanity_client.c file will not be enough to allocate memory blocks (but this will be detectable as I have given boundary conditions for insufficient storage as well). Hence, I would recommend running the sanity_client.c file with allocate(400) instead (if the program is being run with gcc). I sincerely hope my suggestion will be implemented for better analysis. 